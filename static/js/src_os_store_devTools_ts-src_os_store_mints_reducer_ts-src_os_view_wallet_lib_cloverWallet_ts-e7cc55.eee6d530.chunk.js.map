{"version":3,"file":"static/js/src_os_store_devTools_ts-src_os_store_mints_reducer_ts-src_os_view_wallet_lib_cloverWallet_ts-e7cc55.eee6d530.chunk.js","mappings":"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","sources":["os/configs/sol.config.ts","os/configs/register.config.ts","os/configs/index.ts","os/store/devTools.ts","os/store/mints.reducer.ts","os/view/wallet/lib/baseWallet.ts","os/view/wallet/lib/cloverWallet.ts","os/view/wallet/lib/coin98Wallet.ts","os/view/wallet/lib/guestWallet.ts","os/view/wallet/lib/phantomWallet.ts","shared/session.ts","os/view/wallet/lib/secretkeyWallet.ts","os/view/wallet/lib/slopeWallet.ts","os/view/wallet/lib/solflareExtWallet.ts","os/view/wallet/lib/solflareWebWallet.ts","os/view/wallet/lib/solletWebWallet.ts"],"sourcesContent":["import { Net, rpc } from 'shared/runtime'\n\nconst SOLVARS = {\n  spltAddress: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  splataAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n}\n\n/**\n * Contructor\n */\ntype Conf = {\n  node: string\n  swapAddress: string\n  taxmanAddress: string\n} & typeof SOLVARS\n\nconst conf: Record<Net, Conf> = {\n  /**\n   * Development configurations\n   */\n  devnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: '4erFSLP7oBFSVC1t35jdxmbfxEhYCKfoM6XdG2BLR3UF',\n    taxmanAddress: '8UaZw2jDhJzv5V53569JbCd3bD4BnyCfBH3sjwgajGS9',\n  },\n\n  /**\n   * Staging configurations\n   */\n  testnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: '4erFSLP7oBFSVC1t35jdxmbfxEhYCKfoM6XdG2BLR3UF',\n    taxmanAddress: '8UaZw2jDhJzv5V53569JbCd3bD4BnyCfBH3sjwgajGS9',\n  },\n\n  /**\n   * Production configurations\n   */\n  mainnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: 'SSW7ooZ1EbEognq5GosbygA3uWW1Hq1NsFq6TsftCFV',\n    taxmanAddress: '9doo2HZQEmh2NgfT3Yx12M89aoBheycYqH1eaR5gKb3e',\n  },\n}\n\n/**\n * Module exports\n */\nexport default conf\n","import { Env } from 'shared/runtime'\n\nif (\n  typeof process.env.REACT_APP_ID !== 'string' ||\n  typeof process.env.REACT_APP_NAME !== 'string' ||\n  typeof process.env.REACT_APP_URL !== 'string'\n)\n  throw new Error(\n    'Please add REACT_APP_ID, REACT_APP_NAME, REACT_APP_URL in .env.local!',\n  )\n\n/**\n * Contructor\n */\n\ntype Conf = {\n  devAppId: string\n  extra: SenReg\n  senreg: string\n}\n\nconst DEFAULT_APP_ID = process.env.REACT_APP_ID\nconst devApp = {\n  [DEFAULT_APP_ID]: {\n    url: process.env.REACT_APP_URL,\n    appId: DEFAULT_APP_ID,\n    name: process.env.REACT_APP_NAME,\n    author: {\n      name: process.env.REACT_APP_AUTHOR_NAME || '',\n      email: process.env.REACT_APP_AUTHOR_EMAIL || '',\n    },\n    tags: (process.env.REACT_APP_TAGS || '')\n      .split(',')\n      .map((tag) => tag.trim()),\n    description: process.env.REACT_APP_DESCRIPTION || '',\n    verified: false,\n  },\n}\n\nconst conf: Record<Env, Conf> = {\n  /**\n   * Development configurations\n   */\n  development: {\n    devAppId: DEFAULT_APP_ID,\n    extra: devApp,\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n\n  /**\n   * Staging configurations\n   */\n  staging: {\n    devAppId: DEFAULT_APP_ID,\n    extra: devApp,\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n\n  /**\n   * Production configurations\n   */\n  production: {\n    devAppId: DEFAULT_APP_ID,\n    extra: {},\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n}\n\n/**\n * Module exports\n */\nexport default conf\n","import { net, env } from 'shared/runtime'\nimport sol from './sol.config'\nimport register from './register.config'\n\nconst configs = {\n  sol: sol[net],\n  register: register[env],\n}\n\n/**\n * Module exports\n */\nexport default configs\n","import { PublicKey } from '@solana/web3.js'\nimport BN from 'bn.js'\n\n// Bugfix performance\n// https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/Troubleshooting.md#excessive-use-of-memory-and-cpu\nexport const devTools = (appName: string): any => {\n  if (process.env.REACT_APP_ENV !== 'development') return false\n  return {\n    name: appName,\n    actionSanitizer: ({ payload, type }: { payload: any; type: string }) => ({\n      payload,\n      type,\n    }),\n  }\n}\n\n// BigInt Serialization Middleware\n// https://redux-toolkit.js.org/api/serializabilityMiddleware\nconst isPlain = (val: any): boolean => {\n  const isPlainObject = (obj: object): boolean => {\n    if (obj === null) return false\n    const proto = Object.getPrototypeOf(obj)\n    return proto !== null && Object.getPrototypeOf(proto) === null\n  }\n  return (\n    typeof val === 'undefined' ||\n    val === null ||\n    typeof val === 'string' ||\n    typeof val === 'boolean' ||\n    typeof val === 'number' ||\n    Array.isArray(val) ||\n    isPlainObject(val) ||\n    typeof val === 'bigint' ||\n    val instanceof PublicKey ||\n    val instanceof BN ||\n    val instanceof Buffer\n  )\n}\nBigInt.prototype.toJSON = function () {\n  return this.toString() // https://github.com/GoogleChromeLabs/jsbi/issues/30\n}\nexport const bigintSerializationMiddleware = {\n  serializableCheck: {\n    isSerializable: isPlain,\n  },\n}\n","import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport { account, MintData } from '@senswap/sen-js'\n\n/**\n * Interface & Utility\n */\n\nexport type MintsState = Record<string, MintData>\n\n/**\n * Store constructor\n */\n\nconst NAME = 'mints'\nconst initialState: MintsState = {}\n\n/**\n * Actions\n */\n\nexport const getMint = createAsyncThunk<\n  MintsState,\n  { address: string; force?: boolean },\n  { state: any }\n>(`${NAME}/getMint`, async ({ address, force = false }, { getState }) => {\n  if (!account.isAddress(address)) throw new Error('Invalid mint address')\n  if (!force) {\n    const {\n      accounts: { [address]: data },\n    } = getState()\n    if (data) return { [address]: data }\n  }\n  const { splt } = window.sentre\n  const raw = await splt.getMintData(address)\n  return { [address]: raw }\n})\n\nexport const upsetMint = createAsyncThunk<\n  MintsState,\n  { address: string; data: MintData },\n  { state: any }\n>(`${NAME}/upsetMint`, async ({ address, data }) => {\n  if (!account.isAddress(address)) throw new Error('Invalid address')\n  if (!data) throw new Error('Data is empty')\n  return { [address]: data }\n})\n\nexport const deleteMint = createAsyncThunk(\n  `${NAME}/deleteMint`,\n  async ({ address }: { address: string }) => {\n    if (!account.isAddress(address)) throw new Error('Invalid address')\n    return { address }\n  },\n)\n\n/**\n * Usual procedure\n */\n\nconst slice = createSlice({\n  name: NAME,\n  initialState,\n  reducers: {},\n  extraReducers: (builder) =>\n    void builder\n      .addCase(\n        getMint.fulfilled,\n        (state, { payload }) => void Object.assign(state, payload),\n      )\n      .addCase(\n        upsetMint.fulfilled,\n        (state, { payload }) => void Object.assign(state, payload),\n      )\n      .addCase(\n        deleteMint.fulfilled,\n        (state, { payload }) => void delete state[payload.address],\n      ),\n})\n\nexport default slice.reducer\n","import { Transaction } from '@solana/web3.js'\nimport { Provider, WalletInterface, SignedMessage } from '@senswap/sen-js'\n\nimport storage from 'shared/storage'\n\nclass BaseWallet implements WalletInterface {\n  readonly walletType: string\n\n  constructor(walletType: string) {\n    this.walletType = walletType\n    storage.set('WalletType', this.walletType)\n  }\n\n  getProvider = async (): Promise<Provider> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  getAddress = async (): Promise<string> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  signTransaction = async (transaction: Transaction): Promise<Transaction> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  signAllTransactions = async (\n    transactions: Transaction[],\n  ): Promise<Transaction[]> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  signMessage = async (message: string): Promise<SignedMessage> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ): Promise<boolean> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  disconnect = async (): Promise<void> => {\n    storage.clear('WalletType')\n    const provider = await this.getProvider()\n    provider.disconnect()\n  }\n}\n\nexport default BaseWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nclass CloverWallet extends BaseWallet {\n  constructor() {\n    super('Clover')\n  }\n\n  getProvider = async () => {\n    const { clover_solana } = window\n    if (!clover_solana?.isCloverWallet)\n      throw new Error('Wallet is not connected')\n    return clover_solana\n  }\n\n  getAddress = async (): Promise<string> => {\n    const provider = await this.getProvider()\n    const address = await provider.getAccount()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  signTransaction = async (transaction: Transaction): Promise<Transaction> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  signAllTransactions = async (\n    transactions: Transaction[],\n  ): Promise<Transaction[]> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default CloverWallet\n","import { Transaction } from '@solana/web3.js'\nimport { account, SignedMessage } from '@senswap/sen-js'\nimport { decode } from 'bs58'\n\nimport BaseWallet from './baseWallet'\n\nclass Coin98Wallet extends BaseWallet {\n  constructor() {\n    super('Coin98')\n  }\n\n  getProvider = async () => {\n    const { sol } = window?.coin98 || {}\n    if (!sol) throw new Error('Wallet is not connected')\n    return sol\n  }\n\n  getAddress = async (): Promise<string> => {\n    const provider = await this.getProvider()\n    const [address] = (await provider.request({ method: 'sol_accounts' })) || []\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  signTransaction = async (transaction: Transaction): Promise<Transaction> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    const { signature: sig } = await provider.request({\n      method: 'sol_sign',\n      params: [transaction],\n    })\n    const signature = decode(sig)\n    transaction.addSignature(publicKey, signature)\n    return transaction\n  }\n\n  signAllTransactions = async (\n    transactions: Transaction[],\n  ): Promise<Transaction[]> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    const { signatures } = await provider.request({\n      method: 'sol_signAllTransactions',\n      params: [transactions],\n    })\n    signatures.forEach((sig: string, i: number) => {\n      const signature = decode(sig)\n      transactions[i].addSignature(publicKey, signature)\n    })\n    return transactions\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const data = await provider.request({\n      method: 'sol_sign',\n      params: [message],\n    })\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const valid = await account.verifySignature(address, signature, message)\n    return valid as boolean\n  }\n}\n\nexport default Coin98Wallet\n","import { Transaction } from '@solana/web3.js'\nimport { Provider } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nexport const GUEST_ADDRESS = 'GuestAccount11111111111111111111111111111111'\n\ntype ExpanedProvider = Provider & { address: string }\n\nclass GuestWallet extends BaseWallet {\n  constructor(callback: () => void = () => {}) {\n    super('Guest')\n\n    this._callback = callback\n  }\n\n  private _callback = () => {}\n  private _error = () => {\n    throw new Error(\n      'You are in the Guest Mode. Please connect your personal wallet to proceed the action.',\n    )\n  }\n\n  getProvider = async (): Promise<ExpanedProvider> => {\n    const provider = {\n      address: GUEST_ADDRESS,\n      disconnect: () => {},\n    }\n    return provider\n  }\n\n  getAddress = async (): Promise<string> => {\n    const { address } = await this.getProvider()\n    return address\n  }\n\n  signTransaction = async (transaction: Transaction): Promise<Transaction> => {\n    await this._callback()\n    return this._error()\n  }\n\n  signAllTransaction = async (\n    transactions: Transaction[],\n  ): Promise<Transaction[]> => {\n    await this._callback()\n    return this._error()\n  }\n\n  signMessage = async (message: string) => {\n    await this._callback()\n    return this._error()\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    await this._callback()\n    return this._error()\n  }\n}\n\nexport default GuestWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nclass PhantomWallet extends BaseWallet {\n  constructor() {\n    super('Phantom')\n  }\n\n  getProvider = async () => {\n    const { solana } = window\n    if (!solana?.isPhantom) throw new Error('Wallet is not connected')\n    if (solana.isConnected) return solana\n    return await new Promise((resolve) => {\n      solana.on('connect', () => resolve(solana))\n      return solana.connect()\n    })\n  }\n\n  getAddress = async (): Promise<string> => {\n    const provider = await this.getProvider()\n    const address = provider.publicKey.toString()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  signTransaction = async (transaction: Transaction): Promise<Transaction> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  signAllTransactions = async (\n    transactions: Transaction[],\n  ): Promise<Transaction[]> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default PhantomWallet\n","const KEY = 'sentre'\nconst driver = window.sessionStorage\n\nconst convert = (value: string | null) => {\n  try {\n    if (!value) return null\n    return JSON.parse(value)\n  } catch (e) {\n    return false\n  }\n}\n\nconst session = {\n  set: (key: string, value: any) => {\n    let data = convert(driver.getItem(KEY))\n    if (!data || typeof data !== 'object') data = {}\n    data[key] = value\n    driver.setItem(KEY, JSON.stringify(data))\n  },\n\n  get: (key: string) => {\n    let data = convert(driver.getItem(KEY))\n    if (!data || typeof data !== 'object') return null\n    return data[key]\n  },\n\n  clear: (key: string) => {\n    session.set(key, null)\n  },\n}\n\nexport default session\n","import { Transaction, Keypair } from '@solana/web3.js'\nimport { sign, hash } from 'tweetnacl'\nimport { account, Provider } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\nimport session from 'shared/session'\nimport storage from 'shared/storage'\n\ntype ExpanedProvider = Provider & { keypair: Keypair }\n\nclass SecretKeyWallet extends BaseWallet {\n  constructor(secretKey: string, password?: string) {\n    super('SecretKey')\n\n    SecretKeyWallet.setSecretKey(secretKey, password)\n  }\n\n  static xor = (\n    a: Buffer | Uint8Array,\n    b: Buffer | Uint8Array,\n  ): Buffer | Uint8Array => {\n    if (a.length !== b.length)\n      throw new Error('Cannot XOR two different-length buffers')\n    const r = Buffer.alloc(a.length)\n    for (let i = 0; i < r.length; i++) r[i] = a[i] ^ b[i]\n    return r\n  }\n\n  static getPassword = (): string => {\n    let pwd = session.get('Password')\n    if (!pwd) pwd = window.prompt('Input the password:')\n    if (!pwd) throw new Error('User rejects to sign the transaction')\n    session.set('Password', pwd)\n    return pwd\n  }\n\n  static setSecretKey = (secretKeyString: string, pwd?: string): void => {\n    const { secretKey } = account.fromSecretKey(secretKeyString) || {}\n    if (!secretKey) throw new Error('Invalid secret key')\n    pwd = pwd || SecretKeyWallet.getPassword()\n    const seed = hash(Buffer.from(pwd))\n    const confusedSecretKey = SecretKeyWallet.xor(seed, secretKey)\n    storage.set('SecretKey', confusedSecretKey.toString('hex'))\n  }\n\n  static getSecretKey = (pwd?: string): string => {\n    pwd = pwd || SecretKeyWallet.getPassword()\n    const seed = hash(Buffer.from(pwd))\n    const confusedSecretKey = storage.get('SecretKey')\n    if (!confusedSecretKey) throw new Error('Invalid secret key')\n    const secretKey = SecretKeyWallet.xor(\n      seed,\n      Buffer.from(confusedSecretKey, 'hex'),\n    )\n    return secretKey.toString('hex')\n  }\n\n  getProvider = async (): Promise<ExpanedProvider> => {\n    const secretKey = SecretKeyWallet.getSecretKey()\n    const keypair = account.fromSecretKey(secretKey)\n    if (!keypair) throw new Error('Cannot get the keystore-based provider')\n    const provider = {\n      keypair,\n      disconnect: () => session.clear('SecretKey'),\n    }\n    return provider\n  }\n\n  getAddress = async (): Promise<string> => {\n    const { keypair } = await this.getProvider()\n    return keypair.publicKey.toBase58()\n  }\n\n  signTransaction = async (transaction: Transaction): Promise<Transaction> => {\n    const confirmed = window.confirm('Please confirm to sign the transaction!')\n    if (!confirmed) throw new Error('User rejects to sign the transaction')\n    const { keypair } = await this.getProvider()\n    const signData = transaction.serializeMessage()\n    const publicKey = keypair.publicKey\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    const signature = sign.detached(signData, keypair.secretKey)\n    transaction.addSignature(publicKey, Buffer.from(signature))\n    return transaction\n  }\n\n  signAllTransactions = async (\n    transactions: Transaction[],\n  ): Promise<Transaction[]> => {\n    const confirmed = window.confirm('Please confirm to sign the transactions!')\n    if (!confirmed) throw new Error('User rejects to sign the transactions')\n    const { keypair } = await this.getProvider()\n    const txs: Transaction[] = []\n    for (const transaction of transactions) {\n      const signData = transaction.serializeMessage()\n      const publicKey = keypair.publicKey\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n      const signature = sign.detached(signData, keypair.secretKey)\n      transaction.addSignature(publicKey, Buffer.from(signature))\n      txs.push(transaction)\n    }\n    return txs\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const confirmed = window.confirm(\n      `Please confirm to sign the message! Message: ${message}`,\n    )\n    if (!confirmed) throw new Error('User rejects to sign the message')\n    const { keypair } = await this.getProvider()\n    const secretKey = Buffer.from(keypair.secretKey).toString('hex')\n    const data = account.signMessage(message, secretKey)\n    return { ...data }\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const valid = account.verifySignature(address, signature, message)\n    return valid as boolean\n  }\n}\n\nexport default SecretKeyWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account } from '@senswap/sen-js'\nimport { decode, encode } from 'bs58'\n\nimport BaseWallet from './baseWallet'\n\nclass SlopeWallet extends BaseWallet {\n  private provider: any\n  constructor() {\n    super('Slope')\n    this.provider = null\n  }\n\n  getProvider = async () => {\n    const { Slope } = window || {}\n    if (!Slope) throw new Error('Cannot connect to Slope')\n    if (this.provider) return this.provider\n    this.provider = new Slope()\n    await this.provider.connect()\n    return this.provider\n  }\n\n  getAddress = async (): Promise<string> => {\n    const provider = await this.getProvider()\n    const { data } = await provider.connect()\n    if (!data.publicKey) throw new Error('Wallet is not connected')\n    return data.publicKey\n  }\n\n  signTransaction = async (transaction: Transaction): Promise<Transaction> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    const message = encode(transaction.serializeMessage())\n    const { msg, data } = await provider.signTransaction(message)\n    if (!data.publicKey || !data.signature) throw new Error(msg)\n    const signature = decode(data.signature)\n    transaction.addSignature(publicKey, signature)\n    return transaction\n  }\n\n  signAllTransactions = async (\n    transactions: Transaction[],\n  ): Promise<Transaction[]> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    const messages = transactions.map((transaction) =>\n      encode(transaction.serializeMessage()),\n    )\n    const { msg, data } = await provider.signAllTransactions(messages)\n    if (!data.publicKey || data.signatures?.length !== transactions.length)\n      throw new Error(msg)\n    data.signatures.forEach((sig: string, i: number) => {\n      const signature = decode(sig)\n      transactions[i].addSignature(publicKey, signature)\n    })\n    return transactions\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    const slopeAddress = address || (await this.getAddress())\n    const publicKey = account.fromAddress(slopeAddress)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SlopeWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nclass SolflareExtWallet extends BaseWallet {\n  constructor() {\n    super('SolflareExtension')\n  }\n\n  getProvider = async () => {\n    const { solflare } = window\n    if (!solflare.isSolflare) throw new Error('Wallet is not connected')\n    if (solflare.isConnected) return solflare\n    return await new Promise((resolve) => {\n      solflare.on('connect', () => resolve(solflare))\n      return solflare.connect()\n    })\n  }\n\n  getAddress = async (): Promise<string> => {\n    const provider = await this.getProvider()\n    const address = provider.publicKey.toString()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  signTransaction = async (transaction: Transaction): Promise<Transaction> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  signAllTransactions = async (\n    transactions: Transaction[],\n  ): Promise<Transaction[]> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolflareExtWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Provider, SignedMessage } from '@senswap/sen-js'\nimport WalletAdapter from '@project-serum/sol-wallet-adapter'\n\nimport BaseWallet from './baseWallet'\nimport configs from 'os/configs'\n\nconst PROVIDER_URL = 'https://solflare.com/provider'\n\nclass SolflareWebWallet extends BaseWallet {\n  private provider: WalletAdapter & Provider\n\n  constructor() {\n    super('SolflareWeb')\n\n    const {\n      sol: { node },\n    } = configs\n    this.provider = new WalletAdapter(PROVIDER_URL, node)\n  }\n\n  getProvider = async () => {\n    if (!this.provider.connected) await this.provider.connect()\n    return this.provider\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    if (!provider.publicKey) throw new Error('Cannot connect to Solflare')\n    return provider.publicKey.toBase58()\n  }\n\n  signTransaction = async (transaction: Transaction): Promise<Transaction> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  signAllTransactions = async (\n    transactions: Transaction[],\n  ): Promise<Transaction[]> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.sign(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolflareWebWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Provider, SignedMessage } from '@senswap/sen-js'\nimport WalletAdapter from '@project-serum/sol-wallet-adapter'\n\nimport BaseWallet from './baseWallet'\nimport configs from 'os/configs'\n\nconst PROVIDER_URL = 'https://www.sollet.io'\n\nclass SolletWallet extends BaseWallet {\n  private provider: WalletAdapter & Provider\n\n  constructor() {\n    super('SolletWeb')\n\n    const {\n      sol: { node },\n    } = configs\n    this.provider = new WalletAdapter(PROVIDER_URL, node)\n  }\n\n  getProvider = async () => {\n    if (!this.provider.connected) await this.provider.connect()\n    return this.provider\n  }\n\n  getAddress = async (): Promise<string> => {\n    const provider = await this.getProvider()\n    if (!provider.publicKey) throw new Error('Cannot connect to Sollet Web')\n    return provider.publicKey.toBase58()\n  }\n\n  signTransaction = async (transaction: Transaction): Promise<Transaction> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  signAllTransactions = async (\n    transactions: Transaction[],\n  ): Promise<Transaction[]> => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.sign(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolletWallet\n"],"names":["SOLVARS","spltAddress","splataAddress","devnet","node","rpc","swapAddress","taxmanAddress","testnet","mainnet","DEFAULT_APP_ID","process","devApp","url","appId","name","author","email","tags","split","map","tag","trim","description","verified","development","devAppId","extra","senreg","staging","production","sol","net","register","env","devTools","appName","BigInt","prototype","toJSON","this","toString","bigintSerializationMiddleware","serializableCheck","isSerializable","val","Array","isArray","obj","proto","Object","getPrototypeOf","isPlainObject","PublicKey","BN","Buffer","NAME","getMint","createAsyncThunk","async","address","force","getState","account","Error","accounts","data","splt","window","sentre","getMintData","upsetMint","deleteMint","createSlice","initialState","reducers","extraReducers","builder","addCase","fulfilled","state","payload","assign","constructor","walletType","getProvider","getAddress","signTransaction","signAllTransactions","signMessage","verifySignature","signature","message","disconnect","storage","CloverWallet","BaseWallet","super","clover_solana","isCloverWallet","provider","getAccount","publicKey","transaction","feePayer","transactions","forEach","encodedMsg","TextEncoder","encode","sig","from","bufSig","nacl","toBuffer","Coin98Wallet","coin98","request","method","params","decode","addSignature","signatures","i","GuestWallet","callback","_callback","_error","signAllTransaction","PhantomWallet","solana","isPhantom","isConnected","Promise","resolve","on","connect","KEY","driver","sessionStorage","convert","value","JSON","parse","e","session","set","key","getItem","setItem","stringify","get","clear","SecretKeyWallet","secretKey","password","getSecretKey","keypair","toBase58","confirm","signData","serializeMessage","sign","txs","push","setSecretKey","xor","a","b","length","r","alloc","getPassword","pwd","prompt","secretKeyString","seed","hash","confusedSecretKey","SlopeWallet","Slope","msg","messages","slopeAddress","SolflareExtWallet","solflare","isSolflare","SolflareWebWallet","connected","configs","WalletAdapter","SolletWallet"],"sourceRoot":""}