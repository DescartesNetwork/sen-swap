{"version":3,"file":"static/js/202.806ad5d7.chunk.js","mappings":"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","sources":["os/configs/sol.config.ts","os/configs/register.config.ts","os/configs/index.ts","os/store/mints.reducer.ts","os/view/wallet/lib/baseWallet.ts","os/view/wallet/lib/cloverWallet.ts","os/view/wallet/lib/coin98Wallet.ts","os/view/wallet/lib/guestWallet.ts","os/view/wallet/lib/phantomWallet.ts","shared/session.ts","os/view/wallet/lib/secretkeyWallet.ts","os/view/wallet/lib/slopeWallet.ts","os/view/wallet/lib/solflareExtWallet.ts","os/view/wallet/lib/solflareWebWallet.ts","os/view/wallet/lib/solletWebWallet.ts"],"sourcesContent":["import { Net, rpc } from 'shared/runtime'\n\nconst SOLVARS = {\n  spltAddress: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  splataAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n}\n\n/**\n * Contructor\n */\ntype Conf = {\n  node: string\n  swapAddress: string\n  taxmanAddress: string\n} & typeof SOLVARS\n\nconst conf: Record<Net, Conf> = {\n  /**\n   * Development configurations\n   */\n  devnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: '4erFSLP7oBFSVC1t35jdxmbfxEhYCKfoM6XdG2BLR3UF',\n    taxmanAddress: '8UaZw2jDhJzv5V53569JbCd3bD4BnyCfBH3sjwgajGS9',\n  },\n\n  /**\n   * Staging configurations\n   */\n  testnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: '4erFSLP7oBFSVC1t35jdxmbfxEhYCKfoM6XdG2BLR3UF',\n    taxmanAddress: '8UaZw2jDhJzv5V53569JbCd3bD4BnyCfBH3sjwgajGS9',\n  },\n\n  /**\n   * Production configurations\n   */\n  mainnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: 'SSW7ooZ1EbEognq5GosbygA3uWW1Hq1NsFq6TsftCFV',\n    taxmanAddress: '9doo2HZQEmh2NgfT3Yx12M89aoBheycYqH1eaR5gKb3e',\n  },\n}\n\n/**\n * Module exports\n */\nexport default conf\n","import { Env } from 'shared/runtime'\n\nif (\n  typeof process.env.REACT_APP_ID !== 'string' ||\n  typeof process.env.REACT_APP_NAME !== 'string' ||\n  typeof process.env.REACT_APP_URL !== 'string'\n)\n  throw new Error(\n    'Please add REACT_APP_ID, REACT_APP_NAME, REACT_APP_URL in .env.local!',\n  )\n\n/**\n * Contructor\n */\n\ntype Conf = {\n  devAppId: string\n  extra: SenReg\n  senreg: string\n}\n\nconst DEFAULT_APP_ID = process.env.REACT_APP_ID\nconst devApp = {\n  [DEFAULT_APP_ID]: {\n    url: process.env.REACT_APP_URL,\n    appId: DEFAULT_APP_ID,\n    name: process.env.REACT_APP_NAME,\n    author: {\n      name: process.env.REACT_APP_AUTHOR_NAME || '',\n      email: process.env.REACT_APP_AUTHOR_EMAIL || '',\n    },\n    tags: (process.env.REACT_APP_TAGS || '')\n      .split(',')\n      .map((tag) => tag.trim()),\n    description: process.env.REACT_APP_DESCRIPTION || '',\n    verified: false,\n  },\n}\n\nconst conf: Record<Env, Conf> = {\n  /**\n   * Development configurations\n   */\n  development: {\n    devAppId: DEFAULT_APP_ID,\n    extra: devApp,\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n\n  /**\n   * Staging configurations\n   */\n  staging: {\n    devAppId: DEFAULT_APP_ID,\n    extra: devApp,\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n\n  /**\n   * Production configurations\n   */\n  production: {\n    devAppId: DEFAULT_APP_ID,\n    extra: {},\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n}\n\n/**\n * Module exports\n */\nexport default conf\n","import { net, env } from 'shared/runtime'\nimport sol from './sol.config'\nimport register from './register.config'\n\nconst configs = {\n  sol: sol[net],\n  register: register[env],\n}\n\n/**\n * Module exports\n */\nexport default configs\n","import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport { account, MintData } from '@senswap/sen-js'\n\n/**\n * Interface & Utility\n */\n\nexport type MintsState = Record<string, MintData>\n\n/**\n * Store constructor\n */\n\nconst NAME = 'mints'\nconst initialState: MintsState = {}\n\n/**\n * Actions\n */\n\nexport const getMint = createAsyncThunk<\n  MintsState,\n  { address: string; force?: boolean },\n  { state: any }\n>(`${NAME}/getMint`, async ({ address, force = false }, { getState }) => {\n  if (!account.isAddress(address)) throw new Error('Invalid mint address')\n  if (!force) {\n    const {\n      accounts: { [address]: data },\n    } = getState()\n    if (data) return { [address]: data }\n  }\n  const { splt } = window.sentre\n  const raw = await splt.getMintData(address)\n  return { [address]: raw }\n})\n\nexport const upsetMint = createAsyncThunk<\n  MintsState,\n  { address: string; data: MintData },\n  { state: any }\n>(`${NAME}/upsetMint`, async ({ address, data }) => {\n  if (!account.isAddress(address)) throw new Error('Invalid address')\n  if (!data) throw new Error('Data is empty')\n  return { [address]: data }\n})\n\nexport const deleteMint = createAsyncThunk(\n  `${NAME}/deleteMint`,\n  async ({ address }: { address: string }) => {\n    if (!account.isAddress(address)) throw new Error('Invalid address')\n    return { address }\n  },\n)\n\n/**\n * Usual procedure\n */\n\nconst slice = createSlice({\n  name: NAME,\n  initialState,\n  reducers: {},\n  extraReducers: (builder) =>\n    void builder\n      .addCase(\n        getMint.fulfilled,\n        (state, { payload }) => void Object.assign(state, payload),\n      )\n      .addCase(\n        upsetMint.fulfilled,\n        (state, { payload }) => void Object.assign(state, payload),\n      )\n      .addCase(\n        deleteMint.fulfilled,\n        (state, { payload }) => void delete state[payload.address],\n      ),\n})\n\nexport default slice.reducer\n","import { Transaction } from '@solana/web3.js'\nimport {\n  WalletInterface,\n  Provider,\n  Signature,\n  SignedMessage,\n} from '@senswap/sen-js'\n\nimport storage from 'shared/storage'\n\nclass BaseWallet implements WalletInterface {\n  readonly walletType: string\n\n  constructor(walletType: string) {\n    this.walletType = walletType\n    storage.set('WalletType', this.walletType)\n  }\n\n  getProvider = async (): Promise<Provider> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  getAddress = async (): Promise<string> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  signTransaction = async (transaction: Transaction): Promise<Transaction> => {\n    const { signature, publicKey } = await this.rawSignTransaction(transaction)\n    transaction.addSignature(publicKey, signature)\n    return transaction\n  }\n\n  rawSignTransaction = async (transaction: Transaction): Promise<Signature> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  signMessage = async (message: string): Promise<SignedMessage> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ): Promise<boolean> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  disconnect = async (): Promise<void> => {\n    storage.clear('WalletType')\n    const provider = await this.getProvider()\n    provider.disconnect()\n  }\n}\n\nexport default BaseWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Signature, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nclass CloverWallet extends BaseWallet {\n  constructor() {\n    super('Clover')\n  }\n\n  getProvider = async () => {\n    const { clover_solana } = window\n    if (!clover_solana?.isCloverWallet)\n      throw new Error('Wallet is not connected')\n    return clover_solana\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const address = await provider.getAccount()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default CloverWallet\n","import { Transaction } from '@solana/web3.js'\nimport { account, Signature, SignedMessage } from '@senswap/sen-js'\nimport { decode } from 'bs58'\n\nimport BaseWallet from './baseWallet'\n\nclass Coin98Wallet extends BaseWallet {\n  constructor() {\n    super('Coin98')\n  }\n\n  getProvider = async () => {\n    const { sol } = window?.coin98 || {}\n    if (!sol) throw new Error('Wallet is not connected')\n    return sol\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const [address] = (await provider.request({ method: 'sol_accounts' })) || []\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature: sig } = await provider.request({\n      method: 'sol_sign',\n      params: [transaction],\n    })\n    const signature = decode(sig)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const data = await provider.request({\n      method: 'sol_sign',\n      params: [message],\n    })\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const valid = await account.verifySignature(address, signature, message)\n    return valid as boolean\n  }\n}\n\nexport default Coin98Wallet\n","import { Transaction } from '@solana/web3.js'\nimport { Provider } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nexport const GUEST_ADDRESS = 'GuestAccount11111111111111111111111111111111'\n\ntype ExpanedProvider = Provider & { address: string }\n\nclass GuestWallet extends BaseWallet {\n  constructor(callback: () => void = () => {}) {\n    super('Guest')\n\n    this._callback = callback\n  }\n\n  private _callback = () => {}\n  private _error = () => {\n    throw new Error(\n      'You are in the Guest Mode. Please connect your personal wallet to proceed the action.',\n    )\n  }\n\n  getProvider = async (): Promise<ExpanedProvider> => {\n    const provider = {\n      address: GUEST_ADDRESS,\n      disconnect: () => {},\n    }\n    return provider\n  }\n\n  getAddress = async () => {\n    const { address } = await this.getProvider()\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    await this._callback()\n    return this._error()\n  }\n\n  signMessage = async (message: string) => {\n    await this._callback()\n    return this._error()\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    await this._callback()\n    return this._error()\n  }\n}\n\nexport default GuestWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Signature, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nclass PhantomWallet extends BaseWallet {\n  constructor() {\n    super('Phantom')\n  }\n\n  getProvider = async () => {\n    const { solana } = window\n    if (!solana?.isPhantom) throw new Error('Wallet is not connected')\n    if (solana.isConnected) return solana\n    return await new Promise((resolve) => {\n      solana.on('connect', () => resolve(solana))\n      return solana.connect()\n    })\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const address = provider.publicKey.toString()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default PhantomWallet\n","const KEY = 'sentre'\nconst driver = window.sessionStorage\n\nconst convert = (value: string | null) => {\n  try {\n    if (!value) return null\n    return JSON.parse(value)\n  } catch (e) {\n    return false\n  }\n}\n\nconst session = {\n  set: (key: string, value: any) => {\n    let data = convert(driver.getItem(KEY))\n    if (!data || typeof data !== 'object') data = {}\n    data[key] = value\n    driver.setItem(KEY, JSON.stringify(data))\n  },\n\n  get: (key: string) => {\n    let data = convert(driver.getItem(KEY))\n    if (!data || typeof data !== 'object') return null\n    return data[key]\n  },\n\n  clear: (key: string) => {\n    session.set(key, null)\n  },\n}\n\nexport default session\n","import { Transaction, Keypair } from '@solana/web3.js'\nimport { sign, hash } from 'tweetnacl'\nimport { account, Provider, Signature } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\nimport session from 'shared/session'\nimport storage from 'shared/storage'\n\ntype ExpanedProvider = Provider & { keypair: Keypair }\n\nclass SecretKeyWallet extends BaseWallet {\n  constructor(secretKey: string, password?: string) {\n    super('SecretKey')\n\n    SecretKeyWallet.setSecretKey(secretKey, password)\n  }\n\n  static xor = (\n    a: Buffer | Uint8Array,\n    b: Buffer | Uint8Array,\n  ): Buffer | Uint8Array => {\n    if (a.length !== b.length)\n      throw new Error('Cannot XOR two different-length buffers')\n    const r = Buffer.alloc(a.length)\n    for (let i = 0; i < r.length; i++) r[i] = a[i] ^ b[i]\n    return r\n  }\n\n  static getPassword = (): string => {\n    let pwd = session.get('Password')\n    if (!pwd) pwd = window.prompt('Input the password:')\n    if (!pwd) throw new Error('User rejects to sign the transaction')\n    session.set('Password', pwd)\n    return pwd\n  }\n\n  static setSecretKey = (secretKeyString: string, pwd?: string): void => {\n    const { secretKey } = account.fromSecretKey(secretKeyString) || {}\n    if (!secretKey) throw new Error('Invalid secret key')\n    pwd = pwd || SecretKeyWallet.getPassword()\n    const seed = hash(Buffer.from(pwd))\n    const confusedSecretKey = SecretKeyWallet.xor(seed, secretKey)\n    storage.set('SecretKey', confusedSecretKey.toString('hex'))\n  }\n\n  static getSecretKey = (pwd?: string): string => {\n    pwd = pwd || SecretKeyWallet.getPassword()\n    const seed = hash(Buffer.from(pwd))\n    const confusedSecretKey = storage.get('SecretKey')\n    if (!confusedSecretKey) throw new Error('Invalid secret key')\n    const secretKey = SecretKeyWallet.xor(\n      seed,\n      Buffer.from(confusedSecretKey, 'hex'),\n    )\n    return secretKey.toString('hex')\n  }\n\n  getProvider = async (): Promise<ExpanedProvider> => {\n    const secretKey = SecretKeyWallet.getSecretKey()\n    const keypair = account.fromSecretKey(secretKey)\n    if (!keypair) throw new Error('Cannot get the keystore-based provider')\n    const provider = {\n      keypair,\n      disconnect: () => session.clear('SecretKey'),\n    }\n    return provider\n  }\n\n  getAddress = async () => {\n    const { keypair } = await this.getProvider()\n    return keypair.publicKey.toBase58()\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const confirmed = window.confirm('Please confirm to sign the transaction!')\n    if (!confirmed) throw new Error('User rejects to sign the transaction')\n    const { keypair } = await this.getProvider()\n    const signData = transaction.serializeMessage()\n    const publicKey = keypair.publicKey\n    const signature = sign.detached(signData, keypair.secretKey)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const confirmed = window.confirm(\n      `Please confirm to sign the message! Message: ${message}`,\n    )\n    if (!confirmed) throw new Error('User rejects to sign the message')\n    const { keypair } = await this.getProvider()\n    const secretKey = Buffer.from(keypair.secretKey).toString('hex')\n    const data = account.signMessage(message, secretKey)\n    return { ...data }\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const valid = account.verifySignature(address, signature, message)\n    return valid as boolean\n  }\n}\n\nexport default SecretKeyWallet\n","import { Transaction, PublicKey } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Signature } from '@senswap/sen-js'\nimport { decode, encode } from 'bs58'\n\nimport BaseWallet from './baseWallet'\n\nclass SlopeWallet extends BaseWallet {\n  private provider: any\n  constructor() {\n    super('Slope')\n    this.provider = null\n  }\n\n  getProvider = async () => {\n    const { Slope } = window || {}\n    if (!Slope) throw new Error('Cannot connect to Slope')\n    if (this.provider) return this.provider\n    this.provider = new Slope()\n    await this.provider.connect()\n    return this.provider\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const { data } = await provider.connect()\n    if (!data.publicKey) throw new Error('Wallet is not connected')\n    return data.publicKey\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const message = encode(transaction.serializeMessage())\n    const { msg, data } = await provider.signTransaction(message)\n\n    if (!data.publicKey) throw new Error(msg)\n    const publicKey = new PublicKey(data.publicKey)\n    const signature = decode(data.signature)\n\n    return { publicKey, signature } as Signature\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    const slopeAddress = address || (await this.getAddress())\n    const publicKey = account.fromAddress(slopeAddress)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SlopeWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Signature, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nclass SolflareExtWallet extends BaseWallet {\n  constructor() {\n    super('SolflareExtension')\n  }\n\n  getProvider = async () => {\n    const { solflare } = window\n    if (!solflare.isSolflare) throw new Error('Wallet is not connected')\n    if (solflare.isConnected) return solflare\n    return await new Promise((resolve) => {\n      solflare.on('connect', () => resolve(solflare))\n      return solflare.connect()\n    })\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const address = provider.publicKey.toString()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolflareExtWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Provider, Signature, SignedMessage } from '@senswap/sen-js'\nimport WalletAdapter from '@project-serum/sol-wallet-adapter'\n\nimport BaseWallet from './baseWallet'\nimport configs from 'os/configs'\n\nconst PROVIDER_URL = 'https://solflare.com/provider'\n\nclass SolflareWebWallet extends BaseWallet {\n  private provider: WalletAdapter & Provider\n\n  constructor() {\n    super('SolflareWeb')\n\n    const {\n      sol: { node },\n    } = configs\n    this.provider = new WalletAdapter(PROVIDER_URL, node)\n  }\n\n  getProvider = async () => {\n    if (!this.provider.connected) await this.provider.connect()\n    return this.provider\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    if (!provider.publicKey) throw new Error('Cannot connect to Solflare')\n    return provider.publicKey.toBase58()\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.sign(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolflareWebWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Provider, Signature, SignedMessage } from '@senswap/sen-js'\nimport WalletAdapter from '@project-serum/sol-wallet-adapter'\n\nimport BaseWallet from './baseWallet'\nimport configs from 'os/configs'\n\nconst PROVIDER_URL = 'https://www.sollet.io'\n\nclass SolletWallet extends BaseWallet {\n  private provider: WalletAdapter & Provider\n\n  constructor() {\n    super('SolletWeb')\n\n    const {\n      sol: { node },\n    } = configs\n    this.provider = new WalletAdapter(PROVIDER_URL, node)\n  }\n\n  getProvider = async () => {\n    if (!this.provider.connected) await this.provider.connect()\n    return this.provider\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    if (!provider.publicKey) throw new Error('Cannot connect to Sollet Web')\n    return provider.publicKey.toBase58()\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.sign(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolletWallet\n"],"names":["SOLVARS","spltAddress","splataAddress","devnet","node","rpc","swapAddress","taxmanAddress","testnet","mainnet","DEFAULT_APP_ID","process","devApp","url","appId","name","author","email","tags","split","map","tag","trim","description","verified","development","devAppId","extra","senreg","staging","production","sol","net","register","env","NAME","getMint","createAsyncThunk","async","address","force","getState","account","Error","accounts","data","splt","window","sentre","getMintData","upsetMint","deleteMint","createSlice","initialState","reducers","extraReducers","builder","addCase","fulfilled","state","payload","Object","assign","constructor","walletType","getProvider","getAddress","signTransaction","signature","publicKey","this","rawSignTransaction","transaction","addSignature","signMessage","verifySignature","message","disconnect","storage","CloverWallet","BaseWallet","super","clover_solana","isCloverWallet","provider","getAccount","feePayer","encodedMsg","TextEncoder","encode","sig","Buffer","from","toString","bufSig","nacl","toBuffer","Coin98Wallet","coin98","request","method","params","decode","GuestWallet","callback","_callback","_error","PhantomWallet","solana","isPhantom","isConnected","Promise","resolve","on","connect","KEY","driver","sessionStorage","convert","value","JSON","parse","e","session","set","key","getItem","setItem","stringify","get","clear","SecretKeyWallet","secretKey","password","getSecretKey","keypair","toBase58","confirm","signData","serializeMessage","sign","setSecretKey","xor","a","b","length","r","alloc","i","getPassword","pwd","prompt","secretKeyString","seed","hash","confusedSecretKey","SlopeWallet","Slope","msg","PublicKey","slopeAddress","SolflareExtWallet","solflare","isSolflare","SolflareWebWallet","connected","configs","WalletAdapter","SolletWallet"],"sourceRoot":""}